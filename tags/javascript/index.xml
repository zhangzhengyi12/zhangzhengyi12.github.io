<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on Yinode Blog</title>
    <link>https://zhangzhengyi12.github.io/tags/javascript/</link>
    <description>Recent content in JavaScript on Yinode Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 27 Oct 2021 22:56:40 +0000</lastBuildDate>
    
	<atom:link href="https://zhangzhengyi12.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>树形递归结构过滤算法</title>
      <link>https://zhangzhengyi12.github.io/post/202110/%E6%A0%91%E5%BD%A2%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 27 Oct 2021 22:56:40 +0000</pubDate>
      
      <guid>https://zhangzhengyi12.github.io/post/202110/%E6%A0%91%E5%BD%A2%E9%80%92%E5%BD%92%E7%BB%93%E6%9E%84%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/</guid>
      <description>对某个树形结构进行过滤是一个比较常见的场景，但同时想要写出没有问题，并且简洁的代码也并非易事，本文将对这种算法进行简单的分析，并在最后给出代</description>
    </item>
    
    <item>
      <title>JS LocalStorage 导出导入工具</title>
      <link>https://zhangzhengyi12.github.io/post/202110/js-localstorage-%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Thu, 14 Oct 2021 22:56:40 +0000</pubDate>
      
      <guid>https://zhangzhengyi12.github.io/post/202110/js-localstorage-%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E5%B7%A5%E5%85%B7/</guid>
      <description>let genStorageSyncCode = () =&amp;gt; { const kvList = [] for (let i = 0; i &amp;lt; localStorage.length; i++) { const k = localStorage.key(i) const v = localStorage.getItem(k) kvList.push({ k, v }) } const code = `${kvList.map((item) =&amp;gt; { return `localStorage.setItem(&#39;${item.k}&#39;,&#39;${item.v}&#39;)` }).join(&#39;;&#39;)}` return code } console.log(genStorageSyncCode()) 直接导出代码，复制到另外一个页面控制台conso</description>
    </item>
    
    <item>
      <title>红黑树的实现</title>
      <link>https://zhangzhengyi12.github.io/post/202008/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 14 Aug 2020 22:00:30 +0000</pubDate>
      
      <guid>https://zhangzhengyi12.github.io/post/202008/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>手写了一下，用 canvas 简单可视化了一下，方便理解其结构. 代码实现 后面有空再重新树立编写一些更加易于理解的一步步来的文章把，先把代码贴上去，红黑树的</description>
    </item>
    
    <item>
      <title>JavaScript中 Console.log 函数到底有多慢</title>
      <link>https://zhangzhengyi12.github.io/post/202007/javascript-%E4%B8%AD-console.log-%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2/</link>
      <pubDate>Sun, 12 Jul 2020 22:00:30 +0000</pubDate>
      
      <guid>https://zhangzhengyi12.github.io/post/202007/javascript-%E4%B8%AD-console.log-%E5%87%BD%E6%95%B0%E5%88%B0%E5%BA%95%E6%9C%89%E5%A4%9A%E6%85%A2/</guid>
      <description>最近在写JS的时候碰到一个很奇怪的现象，起初是碰到一个树遍历的问题，我封装了一个迭代器用于遍历，并希望能够实际的统计一下性能，使用了cons</description>
    </item>
    
    <item>
      <title>JavaScript中的 == 相等操作符</title>
      <link>https://zhangzhengyi12.github.io/post/201901/javascript%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</link>
      <pubDate>Thu, 17 Jan 2019 06:55:05 +0000</pubDate>
      
      <guid>https://zhangzhengyi12.github.io/post/201901/javascript%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</guid>
      <description>想到这个的主要原因是最近看到了一个非常有趣的题目 [] == ![] 大家有想到结果是什么吗?其实结果是 true，下面是具体的判断链 [] == ![] -&amp;gt; [] == false -&amp;gt; [] == 0 -&amp;gt;</description>
    </item>
    
  </channel>
</rss>