<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="Yinode Blog">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://zhangzhengyi12.github.io//https://yinodimage.oss-cn-hangzhou.aliyuncs.com/20200229004246.png">
    <meta property="twitter:image" content="https://zhangzhengyi12.github.io//https://yinodimage.oss-cn-hangzhou.aliyuncs.com/20200229004246.png" />
    

    
    <meta name="title" content="" />
    <meta property="og:title" content="" />
    <meta property="twitter:title" content="" />
    

    
    <meta name="description" content="我曾赌咒说你美，认为你璀璨；但你却地狱一般黑，夜一般暗">
    <meta property="og:description" content="我曾赌咒说你美，认为你璀璨；但你却地狱一般黑，夜一般暗" />
    <meta property="twitter:description" content="我曾赌咒说你美，认为你璀璨；但你却地狱一般黑，夜一般暗" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="Yinode zhangzhengyi Blog">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>Yinode Blog</title>

    <link rel="canonical" href="/interview/interview/">

    <link rel="stylesheet" href="/css/iDisqus.min.css"/>
	
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    
    <link rel="stylesheet" href="/css/syntax.css">
    
    
    <link rel="stylesheet" href="/css/zanshang.css">
    
    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    
    

    
    
    <script src="/js/jquery.min.js"></script>
    
    
    <script src="/js/bootstrap.min.js"></script>
    
    
    <script src="/js/hux-blog.min.js"></script>

    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/styles/atom-one-dark.min.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    

    <script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });

  MathJax.Hub.Config({
  
  TeX: { equationNumbers: { autoNumber: "AMS" } }
  });
</script>
</head>



<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Yinode Blog</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/tech">tech</a>
                        </li>
                        
                        <li>
                            <a href="/categories/%E5%93%B2%E5%AD%A6">哲学</a>
                        </li>
                        
                        <li>
                            <a href="/categories/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90">精神分析</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/top/gist/">Gist</a></li>
                    
                        <li><a href="/top/notebook/">Notebooks</a></li>
                    
                        <li><a href="/top/books/">BOOKS</a></li>
                    
                        <li><a href="/top/about/">ABOUT</a></li>
                    

                    
		    <li>
                        <a href="/search">SEARCH <img src="/img/search.png" height="15" style="cursor: pointer;" alt="Search"></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('https://yinodimage.oss-cn-hangzhou.aliyuncs.com/20200229004246.png')
    }
</style>
<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1></h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by 
                        
                                Yinode Blog
                         
                        on 
                        Monday, January 1, 0001
                        
                        
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-11 col-lg-offset-1
                col-md-10 col-md-offset-1
                post-container">

                
                <header>
                    <h2>TOC</h2>
                </header>
                <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#数组扁平化">数组扁平化</a></li>
</ul></li>
<li><a href="#类型">类型</a>
<ul>
<li><a href="#加法操作符的基本规则">加法操作符的基本规则</a></li>
<li><a href="#相等操作符的运算规则">相等操作符的运算规则</a></li>
</ul></li>
<li><a href="#继承">继承</a>
<ul>
<li><a href="#寄生组合式继承">寄生组合式继承</a></li>
<li><a href="#用class">用Class</a></li>
</ul></li>
<li><a href="#算法">算法</a>
<ul>
<li><a href="#快速排序">快速排序</a></li>
</ul></li>
<li><a href="#异步">异步</a>
<ul>
<li><a href="#简单的promise-无法-then连续返回新promise-不符合a-规范">简单的Promise（无法.then连续返回新Promise 不符合A+规范）</a></li>
<li><a href="#进程与线程">进程与线程</a></li>
<li><a href="#手写call-apply-bind">手写call,apply,bind</a></li>
<li><a href="#实现instanceof">实现instanceOf</a></li>
<li><a href="#vdom">VDOM</a></li>
<li><a href="#打开浏览器-发生"> 打开浏览器 发生</a></li>
</ul></li>
<li><a href="#算法部分">算法部分</a>
<ul>
<li><a href="#按位实现加法">按位实现加法</a></li>
<li><a href="#所有的排序">所有的排序</a></li>
<li><a href="#颜色排序算法">颜色排序算法</a></li>
<li><a href="#线性统计-获取第k大的值">线性统计 获取第K大的值</a></li>
<li><a href="#堆排序-最大最小堆">堆排序 最大最小堆</a></li>
<li><a href="#单向链表-以及-反转功能">单向链表 以及 反转功能</a></li>
<li><a href="#树的遍历-递归和迭代实现">树的遍历 递归和迭代实现</a></li>
<li><a href="#前驱节点-后驱节点">前驱节点 后驱节点</a></li>
<li><a href="#获取树的最大深度">获取树的最大深度</a></li>
<li><a href="#帅的不行fib">帅的不行Fib</a></li>
<li><a href="#最小硬币算法">最小硬币算法</a></li>
<li><a href="#01背包问题">01背包问题</a></li>
<li><a href="#最长递增子序列">最长递增子序列</a></li>
</ul></li>
<li><a href="#最长公共子序列">最长公共子序列</a></li>
<li><a href="#你在工作中遇到的兼容性问题">你在工作中遇到的兼容性问题</a></li>
<li><a href="#转美式3个数字一个">转美式3个数字一个,</a></li>
<li><a href="#随机化数组">随机化数组</a></li>
<li><a href="#严格模式">严格模式</a></li>
<li><a href="#闭包">闭包</a></li>
<li><a href="#函数节流与函数防抖">函数节流与函数防抖</a></li>
<li><a href="#谈谈什么算全栈工程师">谈谈什么算全栈工程师</a></li>
<li><a href="#正则转换数字到美利坚计数法">正则转换数字到美利坚计数法</a></li>
<li><a href="#面向对象的三大特征">面向对象的三大特征</a></li>
<li><a href="#js中的oop">JS中的OOP</a></li>
<li><a href="#http的请求">HTTP的请求</a></li>
<li><a href="#浏览器重排与重绘">浏览器重排与重绘</a></li>
<li><a href="#执行上下文">执行上下文</a></li>
<li><a href="#this的本质">This的本质</a></li>
<li><a href="#面向对象">面向对象</a>
<ul>
<li><a href="#面向对象的三大特征-1">面向对象的三大特征</a></li>
</ul></li>
<li><a href="#多态">多态</a></li>
<li><a href="#继承-1">继承</a></li>
<li><a href="#封装">封装</a></li>
<li><a href="#原型">原型</a></li>
<li><a href="#自己常用的oop模式">自己常用的OOP模式</a></li>
<li><a href="#开放封闭原则">开放封闭原则</a></li>
<li><a href="#面试tips">面试TIPS</a>
<ul>
<li><a href="#star">STAR</a></li>
<li><a href="#找亮点">找亮点</a></li>
</ul></li>
<li><a href="#自我介绍">自我介绍</a></li>
</ul></li>
</ul>
</nav>
                
                

<h3 id="数组扁平化">数组扁平化</h3>

<pre><code class="language-js">let flat = arr =&gt; arr.reduce((list, v) =&gt; list.concat(Array.isArray(v) ? flat(v) : v), [])
</code></pre>

<p>v2</p>

<pre><code class="language-js">function flat(arr) {
    let res = []
    for (let item of arr) {
        if (Array.isArray(item)) {
            res = res.concat(flat(item))
        } else {
            res.push(item)
        }
    }
    return res
}
</code></pre>

<h2 id="类型">类型</h2>

<h3 id="加法操作符的基本规则">加法操作符的基本规则</h3>

<ul>
<li>两者都为数字 进行普通的数字相加</li>
<li>一方为字符串 则转换另一方为字符串后进行字符串拼接</li>
<li>一方为对象类型 转换为字符串后 继续应用上一条规则</li>
<li>null + 1 = 1 原因是null被转换成了数字 这和红宝书上有冲突，应该null undefined会和另外一项进行自适应 如果是数字 自己也变数字，如果是字符 自己也变字符</li>
</ul>

<h3 id="相等操作符的运算规则">相等操作符的运算规则</h3>

<p><img src="http://upload-images.jianshu.io/upload_images/4279985-6be36e81af21dfc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image" /></p>

<p>[] == ![] -&gt; [] == false -&gt; [] == 0 -&gt; [].valueOf() == 0 -&gt; [].toString() == 0 -&gt; ‘’ == 0 -&gt; 0 == 0 -&gt; true</p>

<h2 id="继承">继承</h2>

<h3 id="寄生组合式继承">寄生组合式继承</h3>

<pre><code class="language-js">function Person(name) {
  this.name = name
}

Person.prototype.sayName = function() {
  console.log(this.name)
}

function Boy(name) {
  this.sex = 'box'
  Person.call(this, name)
}

let prototype = Object.create(Person.prototype)
prototype.constructor = Boy
Boy.prototype = prototype

let boy1 = new Boy(&quot;TOM&quot;)
boy1.sayName()

</code></pre>

<p>特点 继承的只是方法，父类实例不共享变量，并且不需要New一个多余的父类变量，只需要继承父类的原型。这里面的构造函数没有被覆盖，只是建立再一个新的对象上。</p>

<p>所谓寄生组合继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p>

<h3 id="用class">用Class</h3>

<pre><code class="language-js">class Person {
  constructor(name) {
    this.name = name
  }
  sayName() {
    console.log(this.name)
  }
}

class Boy extends Person {
  constructor(name) {
    super(name)
  }
}

let boy1 = new Boy(&quot;Tom&quot;)
boy1.sayName()
</code></pre>

<h2 id="算法">算法</h2>

<h3 id="快速排序">快速排序</h3>

<pre><code class="language-js">function quick_sort1(arr) {
  if (!arr || arr.length &lt; 2) return arr
  const pivot = arr.pop()
  const left = arr.filter(v =&gt; v &lt;= pivot)
  const right = arr.filter(v =&gt; v &gt; pivot)
  return quick_sort1(left).concat([pivot], quick_sort1(right))
}
function quickSort2(arr) {
  if (arr.length &lt;= 1) {
    return arr
  }
  let pi = Math.floor(arr.length / 2)
  let p = arr.splice(pi, 1)[0]

  let left = []
  let right = []
  let i = arr.length
  while (i--) {
    let cur = arr[i]
    if (cur &lt; p) {
      left.push(cur)
    } else {
      right.push(cur)
    }
  }

  return quickSort2(left).concat([p], quickSort2(right))
}

function quickSort(arr,isSmall) {
  // 优化 随机pivot
    const partition = (arr, p, r) =&gt; {
    let pivotIndex = rd(p, r)
    let pivot = arr[pivotIndex]
    let i = p
    for (let j = p; j &lt;= r; j++) {
      if (arr[j] &lt; pivot) {
        if (i === pivotIndex) {
          pivotIndex = j
        }
        let temp = arr[j]
        arr[j] = arr[i]
        arr[i] = temp
        i++
      }
    }

    arr[pivotIndex] = arr[i]
    arr[i] = pivot

    return i
  }
</code></pre>

<h2 id="异步">异步</h2>

<h3 id="简单的promise-无法-then连续返回新promise-不符合a-规范">简单的Promise（无法.then连续返回新Promise 不符合A+规范）</h3>

<pre><code class="language-js">const PromiseStateMap = {
  pending: 'pending',
  resolved: 'resolved',
  rejected: 'rejected'
}
class Promise {
  static resolve(val) {
    if (val instanceof Promise) {
      return val
    }
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve(val)
      })
    })
  }
  static reject(val) {
    if (val instanceof Promise) {
      return val
    }
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        reject(val)
      })
    })
  }
  constructor(fn) {
    this.val = null
    this.state = PromiseStateMap.pending
    this.resolvedCbs = []
    this.rejectedCbs = []
    fn(
      res =&gt; {
        this.val = res
        this.state = PromiseStateMap.resolved
        for (let fn of this.resolvedCbs) {
          fn(this.val)
        }
      },
      res =&gt; {
        this.val = res
        this.state = PromiseStateMap.rejected
        for (let fn of this.rejectedCbs) {
          fn(this.val)
        }
      }
    )
  }
  then(onResolved, onRejected) {
    if (typeof onResolved === 'function') {
      this.resolvedCbs.push(onResolved)
    }
    if (typeof onRejected === 'function') {
      this.rejectedCbs.push(onRejected)
    }
  }
}
</code></pre>

<h3 id="进程与线程">进程与线程</h3>

<p><strong>进程是 CPU 资源分配的最小单位；线程是 CPU 调度的最小单位</strong></p>

<p>可以认为一个进程就是一个正在运行中的程序，而一个线程是这个程序中的执行流，现在的操作系统都是多进程的，可以同时运行多个程序。</p>

<h3 id="手写call-apply-bind">手写call,apply,bind</h3>

<pre><code class="language-js">Function.prototype.mycall = function(ctx, ...args) {
  if (!ctx || typeof ctx !== 'object') {
    console.error('ctx must be a object!')
  }
  let fn = this
  let key = Symbol()
  ctx[key] = fn
  let res = ctx[key](...args)
  return res
}

Function.prototype.myapply = function(ctx, args) {
  if (!ctx || typeof ctx !== 'object') {
    console.error('ctx must be a object!')
  }
  let fn = this
  let key = Symbol()
  ctx[key] = fn
  let res = ctx[key](...args)
  return res
}

Function.prototype.mybind = function(ctx) {
  if (!ctx || typeof ctx !== 'object') {
    console.error('ctx must be a object!')
  }
  let fn = this
  return function(...args) {
    let key = Symbol()
    ctx[key] = fn
    let res = ctx[key](...args)
    return res
  }
}
</code></pre>

<h3 id="实现instanceof">实现instanceOf</h3>

<p>instanceOf的原理是沿着left对象的原型链进行检查 看是否和right构造函数的原型对象相等</p>

<pre><code class="language-js">function myInstanceOf(left, right) {
  let targetProto = right.prototype
  let curProto = Object.getPrototypeOf(left)
  while (curProto) {
    if (curProto === targetProto) {
      return true
    } else {
      curProto = Object.getPrototypeOf(curProto)
    }
  }
  return false
}
</code></pre>

<h3 id="vdom">VDOM</h3>

<p>VDOM是一种技术，一种理念，他把真实的DOM与JS中的对象进行一种映射，也就是说在JS这一端与真实DOM端建立了一层抽象</p>

<p>他的好处有如下几点</p>

<ul>
<li>增强Diff的性能 可以通过对比前后VnodeTree来找到更新的节点，进行局部更新。</li>
<li>建立抽象层，方便移植到多平台，进行SSR</li>
</ul>

<h3 id="打开浏览器-发生"> 打开浏览器 发生</h3>

<p>大纲</p>

<p>DNS解析 多级缓存
获取IP 进行TCP链接 三次握手 SYN SYN_ACK ACK
如果是https 进行TLS加密
获取到过程底层其实是按包来的
获取HTML文件 中间加载各种资源 几乎并发 最多6个套接字同时进行 资源的缓存机制强缓存与协商缓存 资源可能会gzip
合并两棵树 DOM 和 CSSDOM树 进行合并
进行首次绘制 用户看到内容</p>

<h2 id="算法部分">算法部分</h2>

<h3 id="按位实现加法">按位实现加法</h3>

<pre><code class="language-js">function sum(a, b) {
  if (a == 0) return b
  if (b == 0) return a
  let newA = a ^ b
  let newB = (a &amp; b) &lt;&lt; 1
  return sum(newA, newB)
}
</code></pre>

<h3 id="所有的排序">所有的排序</h3>

<pre><code class="language-js">function swap(arr, a, b) {
  let temp = arr[a]
  arr[a] = arr[b]
  arr[b] = temp
}
let testArr = [10, 3, 50, 11, 88, 2390, 1, 2, 11]
// 冒泡排序
function bsort(arr) {
  let len = arr.length
  arr = arr.slice()
  for (let i = 0; i &lt; len; i++) {
    for (let j = 0; j &lt; len - i; j++) {
      if (arr[j] &gt; arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }
  return arr
}
// 插入排序
function iSort(arr) {
  let len = arr.length
  for (let i = 1; i &lt; len; i++) {
    let cur = arr[i]
    let j = i - 1
    while (j &gt;= 0 &amp;&amp; arr[j] &gt; cur) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = cur
  }
  return arr
}
// 快速排序
function qsort(arr) {
  let len = arr.length
  if (len &lt;= 1) {
    return arr
  }
  let pivotIndex = Math.floor(len / 2)
  let pivot = arr.splice(pivotIndex, 1)[0]

  let left = []
  let right = []

  for (item of arr) {
    if (item &lt; pivot) {
      left.push(item)
    } else {
      right.push(item)
    }
  }
  return qsort(left).concat([pivot], qsort(right))
}
// 选择排序
function ssort(arr) {
  let len = arr.length
  arr = arr.slice()
  for (let i = 0; i &lt; len; i++) {
    let index = i
    for (let j = i; j &lt; len; j++) {
      if (arr[j] &lt; arr[index]) {
        index = j
      }
    }
    swap(arr, i, index)
  }
  return arr
}
// 归并排序
function msort(arr) {
  let len = arr.length
  if (len &lt;= 1) {
    return arr
  }

  let middle = Math.floor(len / 2)
  let left = msort(arr.slice(0, middle))
  let right = msort(arr.slice(middle, len))

  let start1 = 0,
    start2 = 0,
    end1 = middle,
    end2 = len - middle
  let res = []
  while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) {
    left[start1] &lt; right[start2]
      ? res.push(left[start1++])
      : res.push(right[start2++])
  }
  while (start1 &lt; end1) {
    res.push(left[start1++])
  }
  while (start2 &lt; end2) {
    res.push(right[start2++])
  }
  return res
}
</code></pre>

<h3 id="颜色排序算法">颜色排序算法</h3>

<pre><code class="language-js">function tSort(arr) {
  let len = arr.length
  let left = -1
  let right = len

  for (let i = 0; i &lt; right; i++) {
    if (arr[i] === 0) {
      swap(arr, i, ++left)
    }
    if (arr[i] === 2) {
      swap(arr, i--, --right)
    }
  }
  return arr
}
</code></pre>

<h3 id="线性统计-获取第k大的值">线性统计 获取第K大的值</h3>

<p>小心splice[]</p>

<p>注意 p = left.length + 1</p>

<pre><code class="language-js">function select(nums, i) {
  let len = nums.length
  if (len &lt;= 1) {
    return nums[0]
  }

  let pivotIndex = Math.floor(len / 2)
  let pivot = nums.splice(pivotIndex, 1)[0]

  let left = []
  let right = []

  for (num of nums) {
    if (num &lt; pivot) {
      left.push(num)
    } else {
      right.push(num)
    }
  }

  let p = left.length + 1
  if (p === i) {
    return pivot
  }
  if (i &lt; p) {
    return select(left, i)
  } else {
    return select(right, i - p)
  }
}
</code></pre>

<h3 id="堆排序-最大最小堆">堆排序 最大最小堆</h3>

<p>建堆的时候小心顺序 i = floor(len / 2) i &gt;=0 i &ndash;</p>

<p>一定要从后往前建</p>

<p>小心heapsize&ndash;的顺序</p>

<pre><code class="language-js">let array = [5, 2, 6, 1, 6, 8, 2, 39, 2, 6, 89, 5, 6, 4, 7]

const swap = (arr, a, b) =&gt; {
  let temp = arr[a]
  arr[a] = arr[b]
  arr[b] = temp
}

const left = i =&gt; i * 2
const right = i =&gt; i * 2 + 1

function HEAPIFY(arr, i) {
  let l = left(i)
  let r = right(i)

  let largest = i

  if (l &lt; arr.heapsize &amp;&amp; arr[l] &gt; arr[largest]) {
    largest = l
  }
  if (r &lt; arr.heapsize &amp;&amp; arr[r] &gt; arr[largest]) {
    largest = r
  }
  if (largest !== i) {
    swap(arr, i, largest)
    HEAPIFY(arr, largest)
  }
}

function BUILD_HEAP(arr) {
  arr.heapsize = arr.length
  for (let i = Math.floor(arr.length / 2); i &gt;= 0; i--) {
    HEAPIFY(arr, i)
  }
  return arr
}

function HEAP_SORT(arr) {
  BUILD_HEAP(arr)
  for (let i = arr.length - 1; i &gt;= 0; i--) {
    swap(arr, 0, i)
    arr.heapsize--
    HEAPIFY(arr, 0)
  }
  return arr
}
</code></pre>

<h3 id="单向链表-以及-反转功能">单向链表 以及 反转功能</h3>

<pre><code class="language-js">// 单项链表

class ListNode {
  constructor(val, next) {
    this.val = val
    this.next = next
  }
}

class LinkList {
  constructor() {
    this.head = null
    this.tail = null
  }
  add(val) {
    if (!this.head || !this.tail) {
      this.head = this.tail = new ListNode(val, null)
    } else {
      this.tail.next = new ListNode(val, null)
      this.tail = this.tail.next
    }
  }
  reverse() {
    if (!this.head | !this.tail) return
    let pre = null
    let current = this.head
    let next = null

    while (current) {
      next = current.next
      current.next = pre
      pre = current
      current = next
    }

    let temp = this.head
    this.head = this.tail
    this.tail = temp
  }
}

let linklist = new LinkList()
linklist.add('a')
linklist.add('b')
linklist.add('c')
linklist.add('d')
linklist.reverse()
</code></pre>

<h3 id="树的遍历-递归和迭代实现">树的遍历 递归和迭代实现</h3>

<pre><code class="language-js">function TreeNode(val) {
  this.val = val
  this.left = this.right = null
}

function traverse(root) {
  if (root) {
    console.log(root)
    if (root.left) {
      traverse(root)
    }
    if (root.right) {
      traverse(root)
    }
  }
}

function pre(root) {
  if (root) {
    let stack = []
    stack.push(root)
    while (stack.length &gt; 0) {
      let item = stack.pop()
      console.log(item)
      if (item.right) {
        stack.push(right)
      }
      if (item.left) {
        stack.push(left)
      }
    }
  }
}

function mid(root) {
  if (root) {
    let stack = []
    stack.push(root)
    while (stack.length &gt;= 1) {
      if (root) {
        stack.push(root)
        root = root.left
      } else {
        let item = stack.pop()
        console.log(item)
        root = item.right
      }
    }
  }
}

function pos(root) {
  if (root) {
    let stack1 = []
    let stack2 = []

    stack1.push(root)
    while (stack1.length &gt;= 1) {
      let item = stack1.pop()
      stack2.push(item)
      if (item.right) {
        stack1.push(item.right)
      }
      if (item.left) {
        stack1.push(item.left)
      }
    }
    while (stack2.length &gt;= 1) {
      console.log(stack2.pop())
    }
  }
}
</code></pre>

<h3 id="前驱节点-后驱节点">前驱节点 后驱节点</h3>

<p>前驱先看Left 后续全部right
后续先看right 后续全部left</p>

<pre><code class="language-js">function successor(node) {
  if (node.right) {
    return findLeft(node.right)
  } else {
    let parent = node.parent
    while (parent &amp;&amp; parent.left === node) {
      node = parent
      parent = node.parent
    }
    return parent
  }
}

function findLeft(node) {
  while (node) {
    if (!node.left) {
      return node
    }
    node = node.left
  }
}

function predecessor(node) {
  if (node.left) {
    return getRight(node.left)
  } else {
    let parent = node.parent
    while (parent &amp;&amp; parent.right === node) {
      node = parent
      parent = node.parent
    }
    return parent
  }
}

function getRight(node) {
  while (node) {
    if (!node.right) {
      return node
    }
    node = node.right
  }
}
</code></pre>

<h3 id="获取树的最大深度">获取树的最大深度</h3>

<pre><code class="language-js">function MAX_DEPTH(root) {
  if (!root) {
    return 0;
  }
  return Math.max(MAX_DEPTH(root.left), MAX_DEPTH(root.right)) + 1;
}
</code></pre>

<h3 id="帅的不行fib">帅的不行Fib</h3>

<pre><code class="language-js">const fib = n =&gt;
  Array(n)
    .fill(1)
    .reduce(nums =&gt; [nums[1], nums[0] + nums[1]], [0, 1])[0]
</code></pre>

<h3 id="最小硬币算法">最小硬币算法</h3>

<pre><code class="language-js">/**
 * @param {*} coins 硬币数组
 * @param {*} m 目标金额
 * @returns {number} 如果拥有解则为一个整数 如果没有则为正无限
 */
function min_coins(coins, m) {
  let table = [0]
  let i = 1
  while (i &lt;= m) {
    table[i] = Infinity
    for (coin of coins) {
      if (i &gt;= coin) {
        table[i] = Math.min(table[i], table[i - coin] + 1)
      }
    }
    i++
  }
  return table[m]
}

console.log(min_coins([3, 6, 8], 16))
</code></pre>

<h3 id="01背包问题">01背包问题</h3>

<p>想象出一个表格 行是物品 列是当前容量</p>

<p>外循环是物品 里面是金额</p>

<p>注意哦 一层是物品 二层是空间</p>

<p>空间要从0开始 一层直接开始</p>

<pre><code class="language-js">/**
 * @param {*} w 物品重量
 * @param {*} v 物品价值
 * @param {*} C 总容量
 * @returns
 */
function knapsack(w, v, C) {
  let len = w.length

  let table = new Array(len).fill(new Array(C + 1).fill(0))

  for (let j = 0; j &lt;= C; j++) {
    table[0][j] = j &gt;= w[0] ? v[0] : 0
  }

  for (let i = 1; i &lt; len; i++) {
    let cw = w[i]
    for (let j = 0; j &lt;= C; j++) {
      table[i][j] = table[i - 1][j]
      if (j &gt;= cw) {
        table[i][j] = Math.max(table[i][j], v[i] + table[i - 1][j - cw])
      }
    }
  }
  return table[len - 1][C]
}

console.log(knapsack([1, 2, 3], [3, 7, 12], 5))
</code></pre>

<h3 id="最长递增子序列">最长递增子序列</h3>

<p>要注意最后的Max哦
第一层循环从1开始</p>

<pre><code class="language-js">function lis(n) {
  let len = n.length
  let array = new Array(len).fill(1)

  for (let i = 1; i &lt; len; i++) {
    for (let j = 0; j &lt; i; j++) {
      if (n[i] &gt; n[j]) {
        array[i] = Math.max(array[i], array[j] + 1)
      }
    }
  }
  return Math.max.apply(Math, array)
}

console.log(lis([0, 3, 4, 17, 2, 8, 6, 10, 11]))
</code></pre>

<h2 id="最长公共子序列">最长公共子序列</h2>

<pre><code class="language-js">let s2 = ['A', 'B', 'C', 'B', 'D', 'A', 'B', 'F', 'G', 'J']
let s1 = ['B', 'D', 'C', 'A', 'B', 'A', 'F', 'H', 'J']

function LCS(s1, s2) {
  let x = s1.length
  let y = s2.length

  s1.unshift(null)
  s2.unshift(null)

  let table = []
  for (let i = 0; i &lt;= x; i++) {
    table[i] = []
    table[i][0] = {
      val: 0
    }
  }
  for (let i = 0; i &lt;= y; i++) {
    table[0][i] = {
      val: 0
    }
  }

  for (let i = 1; i &lt;= x; i++) {
    for (let j = 1; j &lt;= y; j++) {
      if (s1[i] === s2[j]) {
        table[i][j] = {
          lt: true,
          val: table[i - 1][j - 1].val + 1,
          s: s1[i]
        }
      } else if (table[i - 1][j] &gt;= table[i][j - 1]) {
        table[i][j] = {
          top: true,
          val: table[i - 1][j].val
        }
      } else {
        table[i][j] = {
          left: true,
          val: table[i][j - 1].val
        }
      }
    }
  }

  return table
}

function printLcs(table) {
  let i = table.length - 1
  let j = table[0].length - 1

  while (i &gt;= 0 &amp;&amp; j &gt;= 0) {
    let cur = table[i][j]
    if (cur.lt) {
      console.log(cur.s)
      i--
      j--
    }
    if (cur.top) {
      i--
    } else {
      j--
    }
  }
}

let ta = LCS(s1, s2)
printLcs(ta)

</code></pre>

<h2 id="你在工作中遇到的兼容性问题">你在工作中遇到的兼容性问题</h2>

<ol>
<li>URLSearchParams 兼容性问题 在IE和Edge下不可用 解决 使用polyfill</li>
<li>微信IOS下不会主动加载音频文件 解决 先放置一个空的mp3文件 然后首次加载直接load方法+永远不摧毁这个audio</li>
<li>微信的登录跳转缓存问题 解决 将初始化函数传入到一个全局变量中 登录完成后手动触发所有回调</li>
</ol>

<h2 id="转美式3个数字一个">转美式3个数字一个,</h2>

<pre><code class="language-js">function commafy(num) {
  num = num.toString().split('.')
  let head = num[0]
  let tail = num[1]
  head = head
    .split('')
    .reverse()
    .map((v, i) =&gt; (i &amp;&amp; i % 3 === 0 ? v + ',' : v))
    .reverse()
    .join('')
  return head + '.' + tail
}
</code></pre>

<h2 id="随机化数组">随机化数组</h2>

<p>注意，Math.random() 是无法获取一个等于1的数字的 排除1</p>

<pre><code class="language-js">function shuffle(arr) {
  return arr.sort(() =&gt; Math.random() - 0.5)
}

function shuffle(arr) {
  arr = arr.slice()
  let len = arr.length

  for (let i = 0; i &lt; len; i++) {
    let swapIndex = getRandomInt(0, i)
    let temp = arr[i]
    arr[i] = arr[swapIndex]
    arr[swapIndex] = temp
  }
  return arr
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min)
}
</code></pre>

<h2 id="严格模式">严格模式</h2>

<p>使用&rdquo;use strict&rdquo;可以开启严格模式，在严格模式下将会开启更加严格的代码错误检查，很多在非严格模式下允许的操作会在严格模式下被禁止</p>

<p>列如</p>

<ol>
<li>阻止那些意外被创建的全局变量，message = 1 如果该变量没有被声明，则不会帮你自动创建</li>
<li>不允许重复的对象key
3 不允许重复的参数名
4 evel将剥脱在外部作用域创建变量的能力</li>
</ol>

<h2 id="闭包">闭包</h2>

<p><strong>闭包是指一个有权访问另外一个函数作用域中的变量的函数</strong></p>

<p>创建闭包最简单的方法就是从一个函数里面返回另一个匿名函数</p>

<blockquote>
<p>闭包是本质是其内部的函数引用了外部函数的活动对象。只要内部函数的引用不释放，这个活动对象不会被清除引用和回收。内部函数将会一直有能力访问其外部引用的变量。</p>
</blockquote>

<p>上面是ES3的规范</p>

<blockquote>
<p>在ES2018中，可以认为是内部函数引用了外部函数的词法环境</p>
</blockquote>

<p>闭包的真正用途是为了保存状态，让变量不被回收。</p>

<p>这里可以谈一下著名的SICP 里面用闭包实现了序对，某种意义上说，他和OOP的对象很类似，都能存放状态。</p>

<h2 id="函数节流与函数防抖">函数节流与函数防抖</h2>

<pre><code class="language-js">function debounce(fn, dealy) {
  let timer = null
  return function(...args) {
    const ctx = this
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() =&gt; {
      fn.apply(ctx, args)
    }, dealy)
  }
}

function throttle(fn, interval) {
  let last = 0
  return function(...args) {
    const now = Date.now()
    const ctx = this
    if (now - last &gt; interval) {
      last = now
      fn.apply(ctx, args)
    }
  }
}

function compose(fn, dealy, interval) {
  let d = debounce(fn, dealy)
  let t = throttle(fn, interval)
  return function(...args) {
    let ctx = this
    d.apply(ctx, args)
    t.apply(ctx, args)
  }
}

function compose(fn, dealy, interval) {
  let timer = null
  let last = 0
  return function(...args) {
    const ctx = this
    const now = Date.now()
    const run = () =&gt; {
      fn.apply(ctx, args)
    }
    if (now - last &gt; interval) {
      run()
      last = now
      return
    }
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(run, dealy)
  }
}
</code></pre>

<h2 id="谈谈什么算全栈工程师">谈谈什么算全栈工程师</h2>

<p>一 基本掌握前后端开发的某种技术，如一门后端语言+前端框架
二 在思维方式上 要做到没有局限，不会只注意某种环节或者技术，可以从更高的层次观察整个产品，学历能力要非常出色，出现什么问题能够迅速找到相关技术学习并解决问题</p>

<h2 id="正则转换数字到美利坚计数法">正则转换数字到美利坚计数法</h2>

<pre><code class="language-js">function commafy(num) {
  return (
    num &amp;&amp;
    num.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) {
      console.log($0)
      console.log($1)
      return $1 + ','
    })
  )
}
</code></pre>

<h2 id="面向对象的三大特征">面向对象的三大特征</h2>

<p>封装、继承、多态</p>

<p>而JS的多态是与生俱来的</p>

<p>所以JS可以认为是基于原型系统的面向对象语言</p>

<h2 id="js中的oop">JS中的OOP</h2>

<p>JS的面向对象最大特点就是其高度动态性，无论是从实例的角度上，还是从原型的角度上，都异常灵活。</p>

<h2 id="http的请求">HTTP的请求</h2>

<p>GET POST DELETE PUT OPTIONS TRACE HEAD CONNECT PATCH</p>

<h2 id="浏览器重排与重绘">浏览器重排与重绘</h2>

<p>在完成DOM树样式计算后，获得渲染树，此时进行渲染过程</p>

<p>渲染的本质是从抽象的渲染树转化为一张位图</p>

<p>合成是渲染过程中的性能优化，他的目的是减少绘制次数，如把普通元素定义为基本层，transform元素定义为另一个层，最后讲两张导出的位图进行合并，一但transform元素变化，只需要渲染transform这个层就可以完成</p>

<p>重排很可怕，但是重绘如果绘制的次数少，没有特别大的性能问题。</p>

<h2 id="执行上下文">执行上下文</h2>

<p>所谓执行上下文，我们可以看做一个函数运行的必须内容，他定义了函数中能够访问的变量，this，创建变量，结束后重新执行的地方等等。就好比人存活也需要氧气这样的基本环境</p>

<ul>
<li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li>
<li>variable environment：变量环境，当声明变量时使用</li>
<li>code evaluation state：用于恢复代码执行位置。</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm：使用的基础库和内置对象实例。</li>
<li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>

<h2 id="this的本质">This的本质</h2>

<p>this存在于一个函数<strong>执行上下文</strong>中的<strong>词法环境</strong>中</p>

<p>词法环境会拥有一个[[ThisBindingStatus]]属性来标记this的指向，并且会根据私有属性[[thisMode]]的值来对这个this指向进行重新设置</p>

<p>每个函数对象都拥有一个[[thisMode]]属性，他共有三个值</p>

<ul>
<li>global 如果this为undefined或者为null 则设置this为global对象 普通函数</li>
<li>strict 严格模式，严格使用传入的值 对应class方法</li>
<li>lexical 表示从上下文中找 this，这对应了箭头函数。</li>
</ul>

<p>所以，一个函数的this是基于动态绑定的，并且会结合函数的类型和动态传入的this进行组合判断。</p>

<h2 id="面向对象">面向对象</h2>

<h3 id="面向对象的三大特征-1">面向对象的三大特征</h3>

<p>继承、多态、封装</p>

<h2 id="多态">多态</h2>

<p>对不同的对象做相同操作，会产生不同的解释和不同的执行结果。多态性可以让我们把不同的东西当成相同的东西来进行处理。</p>

<p>比如我们有多种类型的盒子 都有一个Open方法，每种盒子的方法各不相同，但是有了多态，就不需要刻意判断盒子的类型来调用不同的方法，直接调用Open 多态会帮我们自动选择最合适的方法。</p>

<p>多态的最大好处就在于 我们 分离了做什么 和 怎么做</p>

<p>从实际编程上讲，我们不需要先去询问对象的类型而去调用对象的某个行为，直接调用就可以了，多态这种特性会帮我们处理好一切。这是一种智力经济。</p>

<h2 id="继承-1">继承</h2>

<p>继承是为了把一些对象中非常相似的部分抽离出来，将相似度部分抽离到父类对象中。</p>

<p>继承的手段可以分为原型和模板(类)</p>

<p>有单继承语言和多继承语言。</p>

<h2 id="封装">封装</h2>

<p>封装的含义是封装一切东西，可以是内部状态，也可以说某个方法,在很多语言中，提供了权限关键字来控制封装</p>

<p>优点：保护状态，模块化，黑箱特性</p>

<h2 id="原型">原型</h2>

<p>原型其实是一种编程范形，而JS是一种基于原型的面向对象的语言，并不是基于对象的语言。</p>

<p>原型的本质是通过一种拷贝操作来方便的创建对象，这个过程甚至都不需要</p>

<h2 id="自己常用的oop模式">自己常用的OOP模式</h2>

<ul>
<li>观察者模式 用于某个小游戏存档系统的实现</li>
<li>装饰器模式 利用AOP的思想，给微信分享动态增加sourceType 提供来源统计功能</li>
<li>代理模式 本地开发建立一个proxy.js 代理到服务器</li>
<li>责任链模式 最典型的就是前端请求拦截器 当然自己也实现过一个拦截器，虽然不太好用</li>
</ul>

<h2 id="开放封闭原则">开放封闭原则</h2>

<blockquote>
<p>你的模块在后续不应该产生改变，但是可以通过扩展来增加行为。</p>
</blockquote>

<p>想要做到完全封闭是完全不可能的</p>

<p>从具体实施上讲，就是让程序分为变化的部分和不变的部分，对这些变化进行抽象和抽离。</p>

<h2 id="面试tips">面试TIPS</h2>

<h3 id="star">STAR</h3>

<p>情景 任务 行动 结果</p>

<p>先来个自我介绍 讲经历 重点在同事都很爱我 工作完成很好 学习很有目的性 重视基础。</p>

<p>讲项目的时候 要重点在于产出，最终做到了一个什么样的效果。</p>

<p>讲技术要从两个纬度 应用纬度(问题，规范，实践，趋势) 和 内部设计纬度（原理，优劣，演进）</p>

<h3 id="找亮点">找亮点</h3>

<p>“我为谁、解决了什么问题”。 可以讲讲活动批量创建 以及LCS解决文本校对
量化结果找提高 文件校对从很高的出错率降低为0 活动之前我没来之前一直崩溃 后来重写之后能够保证很大的并发
复盘过程找创新 对于整个活动的流程 API交互不断优化 让后台压力大大降低 包括使用比较好的存档逻辑
这是要回答“我解决了什么挑战”。 在严重信息不足的情况下(只有两百字的文档)，开发完成了整个项目</p>

<h2 id="自我介绍">自我介绍</h2>

<p>自学 java入门 选择前端 学习基本技能 中间穿插公开课 ，到后期就是一些框架方面的东西。大概学了一年多
第一份工资 静态 没什么好讲的 倒闭了 第二份工作 技术栈方面自己选择使用Vue 主要是做微信里面的活动，最终的产品产出还是让公司很满意的，整个工作周期里面只有一个人 比较寂寞
到后期基本学不到什么东西，所以就走了，走的时候同事都还蛮喜欢我，HR和领导重复多次欢迎我随时回来</p>


                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/interview/jobs/" data-toggle="tooltip" data-placement="top" title="">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                </ul>

                
<div id="disqus-comment"></div>



            </div>
            
            <div class="
                col-lg-11 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/tags/canvas" title="canvas">
                            canvas
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/chrome%E6%89%A9%E5%B1%95" title="chrome扩展">
                            chrome扩展
                        </a>
                        
                        
                        
                        <a href="/tags/csapp" title="csapp">
                            csapp
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/github" title="github">
                            github
                        </a>
                        
                        
                        
                        <a href="/tags/javascript" title="javascript">
                            javascript
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/localstorage" title="localstorage">
                            localstorage
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/nginx" title="nginx">
                            nginx
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/reactnative" title="reactnative">
                            reactnative
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/vue.js" title="vue.js">
                            vue.js
                        </a>
                        
                        
                        
                        <a href="/tags/web" title="web">
                            web
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/websocket" title="websocket">
                            websocket
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B" title="函数式编程">
                            函数式编程
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E5%93%B2%E5%AD%A6" title="哲学">
                            哲学
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7" title="微信公众号">
                            微信公众号
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F" title="微信小程序">
                            微信小程序
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8" title="微信浏览器">
                            微信浏览器
                        </a>
                        
                        
                        
                        <a href="/tags/%E5%BE%B7%E5%9B%BD%E8%A7%82%E5%BF%B5%E8%AE%BA" title="德国观念论">
                            德国观念论
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%84%8F%E8%AF%86%E5%BD%A2%E6%80%81" title="意识形态">
                            意识形态
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%8B%89%E5%BA%B7" title="拉康">
                            拉康
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" title="数据结构">
                            数据结构
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6" title="离散数学">
                            离散数学
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%AE%97%E6%B3%95" title="算法">
                            算法
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA" title="算法导论">
                            算法导论
                        </a>
                        
                        
                        
                        <a href="/tags/%E7%B2%BE%E7%A5%9E%E5%88%86%E6%9E%90" title="精神分析">
                            精神分析
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86" title="计算机原理">
                            计算机原理
                        </a>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <a href="/tags/%E9%BB%91%E6%A0%BC%E5%B0%94" title="黑格尔">
                            黑格尔
                        </a>
                        
                        
                        
                        <a href="/tags/%E9%BD%90%E6%B3%BD%E5%85%8B" title="齐泽克">
                            齐泽克
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a href='' rel="alternate"
                            type="application/rss+xml" title="Yinode Blog">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="mailto:zhangzhengyi12@live.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    

                    
                    
                    

                    

                    
                    
                    <li>
                        <a target="_blank" href="/eizoniko">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-wechat fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/zhangzhengyi12">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Yinode Blog 2023
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function async (u, c) {
        var d = document,
            t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) {
            o.addEventListener('load', function (e) {
                c(null, e);
            }, false);
        }
        s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if ($('#tag_cloud').length !== 0) {
        async ("/js/jquery.tagcloud.js", function () {
            $.fn.tagcloud.defaults = {
                
                color: {
                    start: '#bbbbee',
                    end: '#0085a1'
                },
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    async ("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>






<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-114001572-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</body>
</html>
